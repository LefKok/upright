#summary A simple example of how to implement the upright interfaces.

The source code of this example can be found in Applications/hashtable. This example application provides the functions of a remote hashtable, in which the client can read or write a key-value pair on the server. To illustrate how to handle nondeterminism in server replicas, we extended the functions of the hashtable a bit: when the server receives a write request, it also records the modification time in the hashtable. Furthermore, it also generates a random number for this key/value pair. The client can read the random number and timestamp through the read request.

=Define Requests and Replies=
First, the programmer must define the request and reply between client and server. In this example, they are defined in HTRequest.java and HTReply.java. These two files are simple and this step is of no difference to other distributed systems, so we do not describe it in detail. UpRight library considers all requests and replies as byte arrays, so we also provided Convert.java to convert objects to and from byte arrays.

=Implement the Server=
The server implementation is mainly in HTServer.java. The server class must implement the two server interfaces:
{{{
public class HTServer implements MainAppCPInterface, BackupAppCPInterface
}}}

===Data Structures===
The key data structure is a hashtable: (DataUnit is a triple of value, random number and timestamp):
{{{
LinkedHashMap<String, DataUnit> ht;
}}}
To demonstrate how to keep states, we also add an extra variable, which is added by one for each write operation.
{{{
int writeCount=0;
}}}
The CPAppInterface provides the callback for each function. We will show how to instantiate it later.
{{{
CPAppInterface generalCP=null;
}}}
We use an ArrayList to cache requests. This ArrayList serves as an in memory log and when the server library asks to write log to disk, we write this whole ArrayList to a file and then clear the ArrayList.
{{{
ArrayList<LogEntry> logs=new ArrayList<LogEntry>();
}}}
And two strings are used store the directory to write log and checkpoint file. We can see later these two are used when instantiating the CPAppInterface object.
{{{
private String logDir=null;
private String syncDir=null;
}}}
===Constructor===
Initialize everything:
{{{
        public HTServer(String logDir, String syncDir) throws IOException {
                this.logDir=logDir+File.separator;
                this.syncDir=syncDir+File.separator;
                ht = new LinkedHashMap<String, DataUnit>();
                File logDir2 = new File(this.logDir);
                logDir2.mkdirs();
                File syncDir2 = new File(this.syncDir);
                syncDir2.mkdirs();
        }
}}}

===Execute a request===
If it is read request, then get the data from the hashtable. If it is a write request, then write to hashtable and increase writeCount. Several notices here:
  # This function shows how to use random number and time deterministically: use RequestInfo.getRandom() and RequestInfo.getTime() instead of using java library functions.
  # Write request is logged in this function. Most storage system requires logs to be written to disk before replying to the client. However, UpRight does not have this restriction. We can see here the server just logs the request in memory and then replies. The reason is that UpRight Core writes each request to disk and if the server crashes, the UpRight Core resends these requests to the server, so there will be no data lost.
{{{
        @Override
        public synchronized void execAsync(byte[] request, RequestInfo info) {
                HTRequest req = (HTRequest)(Convert.bytesToObject(request));
                HTReply rep = null;
                String key = req.getKey();
                if(req.getType() == HTRequest.READ){
                        if(ht.containsKey(key)){
                                rep = new HTReply(false, ht.get(key));
                        }else{
                                rep = new HTReply(true, null);
                        }
                } else {        // WRITE operation
                        //Write requests must be logged. 
                        DataUnit data=new DataUnit(req.getValue(), info.getRandom(), info.getTime());
                        logs.add(new LogEntry(key,data));
                        ht.put(key, data);
                        writeCount++;
                        rep = new HTReply(false, null);
                }
                generalCP.execDone(Convert.objectToBytes(rep), info);

        }
}}}

=Application Client=
The client code is simple. Use ClientShimBaseNode.execute to send requests and then handle the reply.
{{{
package Applications.hashtable;

import Applications.hashtable.HTRequest.ht_req_type;
import BFT.clientShim.ClientShimBaseNode;
import BFT.network.TCPNetwork;

public class HTClient{
        ClientShimBaseNode clientShim;
        public HTClient(String membership, int id){
                clientShim = new ClientShimBaseNode(membership, id);
                clientShim.setNetwork(new TCPNetwork(clientShim));
                clientShim.start();
        }

        public void write(String key, int value)
        {
                 HTRequest req = new HTRequest(ht_req_type.WRITE, key, value);
                 HTReply rep = HTReply.getHTReplyFromBytes(clientShim.execute(req.toBytes()));
                 if(rep.error){
                        throw new RuntimeException("Write failed");
                 }
        }

        public int read(String key){
                HTRequest req = new HTRequest(ht_req_type.READ, key, 0);
                HTReply rep = HTReply.getHTReplyFromBytes(clientShim.execute(req.toBytes()));
                if(rep.error){
                      throw new RuntimeException("Read failed");
                }
                return rep.value;
        }
}
}}}

=Application Server=
The application server must implement the two sets of interfaces. In this example, the consumeLog and loadSnapshot functions in two interfaces are the same, so this application server just needs to implement five functions: execAysnc, flushAndStartNewLog, consumeLog, sync and loadSnapshot. And the main function shows how to connect the server with the UpRight server library.
 
{{{
package Applications.hashtable;

import java.io.DataInputStream;
import java.io.DataOutputStream;
import java.io.File;
import java.io.FileInputStream;
import java.io.FileNotFoundException;
import java.io.FileOutputStream;
import java.io.IOException;
import java.io.ObjectInputStream;
import java.io.ObjectOutputStream;
import java.util.LinkedHashMap;
import java.util.LinkedList;

import Applications.hashtable.HTRequest.ht_req_type;
import BFT.generalcp.CPAppInterface;
import BFT.generalcp.MainAppCPInterface;
import BFT.generalcp.BackupAppCPInterface;
import BFT.generalcp.GeneralCP;
import BFT.generalcp.RequestInfo;
import BFT.serverShim.ShimBaseNode;
import java.io.EOFException;
import java.util.Collection;
import java.util.Iterator;

public class HTSingleApp implements MainAppCPInterface, BackupAppCPInterface{

        LinkedHashMap<String, Integer> ht;
        CPAppInterface generalCP;

        DataOutputStream log;
        String logfile;
        DataOutputStream sync;
        String syncfile;
        int syncCounter;

        private String log_prefix=null;
        private String sync_prefix=null;
        static String syncbasename="ht_sync_";

        public HTSingleApp(String log_prefix, String sync_prefix) throws IOException {
                this.log_prefix=log_prefix+File.separator;
                this.sync_prefix=sync_prefix+File.separator;
                ht = new LinkedHashMap<String, Integer>();
                File logDir = new File(this.log_prefix);
                logDir.mkdirs();
                logfile = this.log_prefix+"ht_log_0";
                log = new DataOutputStream(new FileOutputStream(logfile));
                syncCounter = 0;
                syncfile = syncbasename+syncCounter;
       }

        public void setGenCP(CPAppInterface cp) {
                generalCP = cp;
        }

        @Override
        public synchronized void execAsync(byte[] request, RequestInfo info) {

                HTRequest req = HTRequest.getHTReqeustFromBytes(request);
                HTReply rep = new HTReply();
                String key = req.key;
                if(req.type == ht_req_type.READ){

                        if(ht.containsKey(key)){
                                rep.error = false;
                                rep.value = ht.get(key);
                        }else{
                                rep.error = true;
                        }
                } else {
                        // WRITE operation
                        try {
                                // log this request
                                log.writeUTF(key);
                                log.writeInt(req.value);
                        } catch (IOException e) {
                                // TODO Auto-generated catch block
                                e.printStackTrace();
                                System.exit(-1);
                        }
                        ht.put(key, req.value);
                        rep.error = false;
                }

                generalCP.execDone(rep.toBytes(), info);

        }

        @Override
        public synchronized void flushAndStartNewLog(long seqNo) {
                DataOutputStream oldLog = log;
                //LogInfo info = new LogInfo(oldLog, logfile, seqNo);
                //logQueue.enqueue(info);
            try {
                oldLog.flush();
                oldLog.close();
                File logFile = new File(logfile);

            } catch (IOException e) {
                e.printStackTrace();
                System.exit(-1);
            }
            logfile = log_prefix+"ht_log_" + seqNo;
            try {
                    log = new DataOutputStream(new FileOutputStream(logfile));
            } catch (FileNotFoundException e) {
                    e.printStackTrace();
                    System.exit(-1);
            }
            generalCP.flushDone(seqNo, log_prefix+"log_"+seqNo);
        }

        @Override
        public void consumeLog(String fileName) {
                DataInputStream is = null;
            try {
                is = new DataInputStream(new FileInputStream(fileName));
                while (true) { // exception catches EOF
                    String key = is.readUTF();
                    int value = is.readInt();

                    ht.put(key, value);
                }
            } catch (EOFException eof) {
                System.out.println(" >> Normal program termination.");
            } catch (FileNotFoundException noFile) {
                System.err.println("File not found! " + noFile);
            } catch (IOException io) {
                System.err.println("I/O error occurred: " + io);
            } catch (Throwable anything) {
                System.err.println("Abnormal exception caught !: " + anything);
            } finally {
                if (is != null) {
                    try {
                        is.close();
                    } catch (IOException ignored) {
                    }
                }
            }

            generalCP.consumeLogDone(fileName);

        }

        @Override
        public synchronized void loadSnapshot(String fileName) {
                try {
                        ObjectInputStream ois = new ObjectInputStream(new FileInputStream(fileName));
                        ht = (LinkedHashMap<String, Integer>) ois.readObject();
                        int index=fileName.indexOf(syncbasename);
                        syncCounter=Integer.parseInt(fileName.substring(index+syncbasename.length()));
                        syncCounter++;
                        syncfile=syncbasename + syncCounter;
                        generalCP.loadSnapshotDone();
                } catch (FileNotFoundException e) {
                        e.printStackTrace();
                        System.exit(-1);
                } catch (IOException e) {
                        e.printStackTrace();
                        System.exit(-1);
                } catch (ClassNotFoundException e) {
                        e.printStackTrace();
                        System.exit(-1);
                }
                generalCP.loadSnapshotDone();

        }

        @Override
        public void sync() {
            try {
                ObjectOutputStream oos = new ObjectOutputStream(new FileOutputStream(sync_prefix+syncfile));
                oos.writeObject(ht);
            } catch (FileNotFoundException e) {
                e.printStackTrace();
                System.exit(-1);
            } catch (IOException e) {
                e.printStackTrace();
                System.exit(-1);
            }
            String writtenSyncFile = syncfile;
            syncCounter++;
            syncfile = syncbasename + syncCounter;

            generalCP.syncDone(sync_prefix+writtenSyncFile);
        }

        public static void main(String args[]) throws Exception{

            if(args.length!=4){
                System.out.println("Usage: java Applications.hashtable <id> <config_file> <log_path> <snapshot_path>");
            }
            GeneralCP generalCP = new GeneralCP(Integer.parseInt(args[0]), args[1], args[2], args[3]);
            HTSingleApp main = new HTSingleApp(args[2],args[3]);
            HTSingleApp helper = new HTSingleApp(args[2], args[3]);
            main.setGenCP(generalCP);
            helper.setGenCP(generalCP);
            generalCP.setupApplication(main, helper);
        }

}


}}}