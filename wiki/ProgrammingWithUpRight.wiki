#summary Writing programs with UpRight

UpRight provides libraries for both application clients and servers. By connecting to these libraries, the application is incorporated into the UpRight infrastructure. The programmer just needs to provide the functions of a single server application, and then the server is automatically replicated by UpRight.

= Model =

== State machine replication ==
UpRight replicates the application servers for fault tolerance. It requires c+b+1 replicas to tolerate up to c faults of which b may be Byzantine. E.g., 2 servers (c=1, b=0) can keep working even if one crashes (but have trouble if either is incorrect); E.g., 3 servers (c=1, b=1) can keep working even if 1 replica crashes or starts giving the wrong responses.

== Requirements for state machine replication==
  * *Ordered requests*: requests from all clients must be executed and responded in the same order on all server replicas. UpRight compares the responses from different replicas. If one response is different from the others, it is considered to be incorrect. To be accurate, UpRight requires at least b+1 same responses for one request. Ordered requests also provides strong consistency and linearizability for the system. The ordered nodes (2b+c+1 nodes) in UpRight Core guarantees that the requests arrive at all the replicas in the same order. All the server replicas need to do is to execute these requests and send responses in exactly the same order.
  * *Deterministic execution*: all replicas must give the same response for the same request. This means that servers must execute the request in a deterministic way. There should be no randomness in the execution. See [NonDeterminism common sources of nondeterminism and tips about how to solve them].
  * *Deterministic checkpoints*: UpRight also requires all replicas to provide the same checkpoints at the same time. Therefore, checkpoints should also be deterministic. Since checkpoint usually takes a long time, usually it is necessary to execute requests and perform checkpoint concurrently and it is quite challenging for a server to generate deterministic checkpoint while still processing other requests. The simplest approach is *blocking checkpoint*, which blocks the execution while performing checkpoints, but this approach may introduce unacceptable latencies while doing the checkpoint. UpRight suggests two kinds of asynchronous checkpoint techniques, if blocking checkpoint is not affordable: 1) *Primary-Backup*: a primary instance executes the request and passes the requests to the backup instance. While performing checkpoint, the backup instance writes all states to the checkpoint file and the primary instance can still keep executing requests during this procedure. 2) *Application Copy-on-Write (COW)*: if you're willing to spend more time, application COW is an efficient way to do asynchronous checkpoint. How to do it actually depends on the application. UpRight library provides support for the Primary-Backup approach.
  * *Client-oblivious recovery*: if a replica crashes and then recovers from the checkpoints and logs, it should still be able to provide the same responses and checkpoints as the other replicas. A client should not see any difference between a recovered server and a normal server. This actually requires applications to keep more information as persistent state. For example, for a stateful service, the server should also keep the session information of each client in the log and checkpoint, so that when it recovers, it can still serve these clients correctly.

[http://www.cs.utexas.edu/~yangwang/UpRightModel.jpg]

== Architecture and Procedure ==
 
The architecture is shown in the figure. UpRight works as follows:
  # The client issues a request to the client library.
  # The client library sends the request to UpRight Core and waits for the reply. It returns the result to the client once it has a sufficient number (b+1) of matching replies to guarantee correctness.
  # The UpRight core agrees on the order of requests from all clients.
  # The UpRight core sends requests to server library in order.
  # The server library sends requests to the application server, which will execute the request and send reply back to the server library.
  # The server library sends reply to client library.
  # Periodically, the server library asks the application server to perform checkpoint. 

= Creating an UpRight Service =
  # Server: to be incorporated into the UpRight system, the application server needs to implement a interface *AppCPInterface*. This interface defines the functionality of the application, including request execution, checkpoint and recovery. 
  # Client: the client library provides an interface to send requests. The application client should use this interface instead of sending requests to sockets.
For details of these interfaces, see [InterfaceSpecification interface specification]. <br/>
We have provided an example of how to build an UpRight Service. It is a remote hashtable, in which clients can set or get key/value pairs on the server. The example is rather simple, but has all the features described above. [UpRightExample Go to the example].

 