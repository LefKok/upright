#summary Writing programs with UpRight

UpRight provides libraries for both application clients and servers. By connecting to these libraries, the application is incorporated into the UpRight infrastructure. The programmer just needs to provide the functions of a single server application, and then the server is automatically replicated by UpRight.

= Model =

== State machine replication ==
UpRight replicates the application servers for fault tolerance. It requires c+b+1 replicas to tolerate up to c faults of which b may be Byzantine. E.g., 2 servers (c=1, b=0) can keep working even if one crashes (but have trouble if either is incorrect); E.g., 3 servers (c=1, b=1) can keep working even if 1 replica crashes or starts giving the wrong responses.

== Requirements for state machine replication==
  * Ordered requests: requests from all clients must be executed and responded in the same order on all server replicas. UpRight compares the responses from different replicas. If one response is different from the others, it is considered to be incorrect. To be accurate, UpRight requires at least b+1 same responses for one request. Ordered requests also provides strong consistency and linearizability for the system. The ordered nodes (2b+c+1 nodes) in UpRight Core put requests from all clients in the same order and give them to the server replicas. The server replicas must execute these requests and send responses in exactly the same order.
  * Deterministic execution: all replicas must give the same response for the same request. This means that servers must execute the request in a deterministic way. There should be no randomness in the execution. See [NonDeterminism here] for some common sources of nondeterminism and tips about how to solve them.
  * Deterministic checkpoints: UpRight also requires all replicas to provide the same checkpoints at the same time. Therefore, checkpoints should also be deterministic. Since checkpoint usually takes a long time, applications may want to execute requests and perform checkpoint concurrently and it is quite challenging for a server to generate deterministic checkpoint while still processing other requests. For simplicity, UpRight lets you use your existing server, assuming that it can produce logs of the events it processes and produce checkpoints. UpRight starts two instances of servers on the same machine (as shown in the following figure): the _Main_ instance for executing requests and writing requests to log files and the _Backup_ instance for merging all the previous logs into the checkpoint file. The benefit of this method is that it separates the execution and checkpoint into two instances, so that they will not interfere with each other. The cost is that it increases memory and CPU overhead. Of course, if you are willing to do a bit more work, you can reduce overheads by using Copy On Write (COW) technique, etc.
  * Deterministic recovery: if a replica crashes and then recovers from the checkpoints and logs, it should still be able to provide the same responses and checkpoints as the other replicas. This actually requires applications to keep more information as persistent state. For example, for a stateful service, the server should also keep the session information of each client in the log and checkpoint, so that when it recovers, it can still serve these clients correctly.

[http://www.cs.utexas.edu/~yangwang/UpRightModel.jpg]

== Architecture and Procedure ==
 
The architecture is shown in the figure. UpRight works as follows:
  # The client issues a request to the client library.
  # The client library sends the request to UpRight Core and waits for the reply. It returns the result to the client once it has a sufficient number (b+1) of matching replies to guarantee correctness.
  # The UpRight core agrees on the order of this request among all the requests.
  # The UpRight core sends requests to server library in order.
  # The server library sends requests to the _Main_ server instance, which will execute the request and send reply back to the server library.
  # The server library sends reply to client library.
  # Periodically, the server library asks the _Main_ server instance to flush logs to disks and then the server library asks the _Backup_ server instance to load and replay the log.
  # Periodically, the server library asks the _Backup_ server instance to perform checkpoint. The checkpoint interval is much larger than the log flush interval.

= Creating an UpRight Service =
To be incorporated into the UpRight system, the application server needs to implement two sets of interfaces: the MainAppCPInterface and BackupAppCPInterface. The first interface defines the functionality of the _Main_ server instance, including request execution, log flushing log replay and recovery. The second interface defines the functionality of the _Backup_ server instance, including log replay, checkpoint and also recovery. Notice both interfaces include functions of log replay and recovery. Actually, it is possible to use the same code for both interfaces.
The client library provides an interface to send requests. The application client should use this interface instead of sending requests to sockets.
See details of these interfaces, see here.
We have provided an example of how to build an UpRight Service. The example is rather simple, but has all the features described above. See here for the example.

  * MainAppCPInterface.execAsync: execute a request. After finished, the application should call CPAppInterface.execDone to send the result back.
  * MainAppCPInterface.flushAndStartNewLog: flush the current log file and start a new one. Call CPAppInterface.flushDone to give the log file to UpRight and this log file should never be modified, renamed or deleted in the future.
  * MainAppCPInterface.consumeLog: read the log and replay the requests in the log. Call CPAppInterface.consumeLogDone when finished.
  * MainAppCPInterface.loadSnapshot: load the snapshot file. Call CPAppInterface.loadSnapshotDone when finished.

  * BackupAppCPInterface.consumeLog: read the log and replay the requests in the log. The implementation should be similar to MainAppCPInterface.consumeLog, but this is executed in the backup instance. Also call CPAppInterface.consumeLogDone when finished.
  * BackupAppCPInterface.sync: write all the application states into a snapshot file. Call CPAppInterface.syncDone when finished.
  * BackupAppCPInterface.loadSnapshot: similar to MainAppCPInterface.loadSnapshot.

==Notices==
  * Never modify a log file or a snapshot file after returning it to UpRight.
  * The application must provide determined log and snapshot files. This means that after executing the same sequence of requests, the server should give the same log and snapshot file. There should be no randomness in these files. In reality, time, multi thread, etc, can cause non-determinisms and they should be carefully avoided.

=Application Client=
UpRight takes care of the network communication, so the client should not touch any socket code any more. Instead, UpRight provides a function for clients to send requests:
  * ClientShimInterface.execute: the request will be passed to the application server through the execAsync interface. Currently, execute is a blocking call and it will wait for the reply from the server.