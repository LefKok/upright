#summary Writing programs with UpRight

UpRight provides libraries for both application clients and servers. By connecting to these libraries, the application is incorporated into the UpRight infrastructure. The programmer just needs to provide the functions of a single server application, and then the server is automatically replicated by UpRight.

= Model =

== State machine replication ==
UpRight replicates the application servers for fault tolerance. It requires c+b+1 replicas to tolerate up to c faults of which b may be Byzantine. E.g., 2 servers (c=1, b=0) can keep working even if one crashes (but have trouble if either is incorrect); E.g., 3 servers (c=1, b=1) can keep working even if 1 replica crashes or starts giving the wrong responses.

== Requirements for state machine replication==
  * Ordered requests: requests from all clients must be executed and responded in the same order on all server replicas. UpRight compares the responses from different replicas. If one response is different from the others, it is considered to be incorrect. To be accurate, UpRight requires at least b+1 same responses for one request. Ordered requests also provides strong consistency and linearizability for the system. The ordered nodes (2b+c+1 nodes) in UpRight Core put requests from all clients in the same order and give them to the server replicas. The server replicas must execute these requests and send responses in exactly the same order.
  * Deterministic execution and checkpoints: all replicas must give the same response for one request. This means that servers must execute the request in a deterministic way. There should be no randomness in the execution. UpRight also requires all replicas to provide the same checkpoints at the same time. Therefore, checkpoints should also be deterministic. Furthermore, if a replica crashes and recovers, it should still be able to provide the same responses and checkpoints as the other replicas. Deterministic execution and checkpoints is the most challenging requirement for the application. See [NonDeterminism here] for some common sources of nondeterminism and tips about how to solve them.
The UpRight library sits between the application client and server. It takes care of all the network communication, so the application does not need to touch socket.

On the client side, the application just needs to pass the request to the UpRight client library and then handles the reply.

On the server side, things are a bit more complicated. UpRight requires two instances of application servers: the main instance for executing requests and writing request to log files and the backup instance for merging all the previous logs into a big snapshot file. Correspondingly, the application must implement two sets of interface functions for these two instances. The following parts give a brief description of the interface functions. For details, please see the JavaDoc. And here is an [UpRightExample example] application of how to implement these interfaces.


[http://www.cs.utexas.edu/~yangwang/UpRightModel.jpg]

= Application Server =
The application server needs to implement two sets of interfaces: the MainAppCPInterface and BackupAppCPInterface. All the interface functions are asynchronous, so the application server should call the callback functions after finishing the execution.

  * MainAppCPInterface.execAsync: execute a request. After finished, the application should call CPAppInterface.execDone to send the result back.
  * MainAppCPInterface.flushAndStartNewLog: flush the current log file and start a new one. Call CPAppInterface.flushDone to give the log file to UpRight and this log file should never be modified, renamed or deleted in the future.
  * MainAppCPInterface.consumeLog: read the log and replay the requests in the log. Call CPAppInterface.consumeLogDone when finished.
  * MainAppCPInterface.loadSnapshot: load the snapshot file. Call CPAppInterface.loadSnapshotDone when finished.

  * BackupAppCPInterface.consumeLog: read the log and replay the requests in the log. The implementation should be similar to MainAppCPInterface.consumeLog, but this is executed in the backup instance. Also call CPAppInterface.consumeLogDone when finished.
  * BackupAppCPInterface.sync: write all the application states into a snapshot file. Call CPAppInterface.syncDone when finished.
  * BackupAppCPInterface.loadSnapshot: similar to MainAppCPInterface.loadSnapshot.

==Notices==
  * Never modify a log file or a snapshot file after returning it to UpRight.
  * The application must provide determined log and snapshot files. This means that after executing the same sequence of requests, the server should give the same log and snapshot file. There should be no randomness in these files. In reality, time, multi thread, etc, can cause non-determinisms and they should be carefully avoided.

=Application Client=
UpRight takes care of the network communication, so the client should not touch any socket code any more. Instead, UpRight provides a function for clients to send requests:
  * ClientShimInterface.execute: the request will be passed to the application server through the execAsync interface. Currently, execute is a blocking call and it will wait for the reply from the server.