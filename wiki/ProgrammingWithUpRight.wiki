#summary Writing programs with UpRight

UpRight provides libraries for both application clients and servers. By connecting to these libraries, the application is incorporated into the UpRight infrastructure. The programmer just needs to provide the functions of a single server application, and then the server is automatically replicated by UpRight.

= Model =

== State machine replication ==
UpRight replicates the application servers for fault tolerance. It requires c+b+1 replicas to tolerate up to c faults of which b may be Byzantine. E.g., 2 servers (c=1, b=0) can keep working even if one crashes (but have trouble if either is incorrect); E.g., 3 servers (c=1, b=1) can keep working even if 1 replica crashes or starts giving the wrong responses.

== Requirements for state machine replication==
  * Ordered requests: requests from all clients must be executed and responded in the same order on all server replicas. UpRight compares the responses from different replicas. If one response is different from the others, it is considered to be incorrect. To be accurate, UpRight requires at least b+1 same responses for one request. Ordered requests also provides strong consistency and linearizability for the system. The ordered nodes (2b+c+1 nodes) in UpRight Core guarantees that the requests arrive at all the replicas in the same order. All the server replicas need to do is to execute these requests and send responses in exactly the same order.
  * Deterministic execution: all replicas must give the same response for the same request. This means that servers must execute the request in a deterministic way. There should be no randomness in the execution. See [NonDeterminism common sources of nondeterminism and tips about how to solve them].
  * Deterministic checkpoints: UpRight also requires all replicas to provide the same checkpoints at the same time. Therefore, checkpoints should also be deterministic. Since checkpoint usually takes a long time, applications may want to execute requests and perform checkpoint concurrently and it is quite challenging for a server to generate deterministic checkpoint while still processing other requests. For simplicity, UpRight lets you use your existing server, assuming that it can produce logs of the events it processes and produce checkpoints. UpRight starts two instances of servers on the same machine (as shown in the following figure): the _Main_ instance for executing requests and writing requests to log files and the _Backup_ instance for merging all the previous logs into the checkpoint file. The benefit of this method is that it separates the execution and checkpoint into two instances, so that they will not interfere with each other. The cost is that it increases memory and CPU overhead. Of course, if you are willing to do a bit more work, you can reduce overheads by using Copy On Write (COW) technique, etc.
  * Deterministic recovery: if a replica crashes and then recovers from the checkpoints and logs, it should still be able to provide the same responses and checkpoints as the other replicas. This actually requires applications to keep more information as persistent state. For example, for a stateful service, the server should also keep the session information of each client in the log and checkpoint, so that when it recovers, it can still serve these clients correctly.

[http://www.cs.utexas.edu/~yangwang/UpRightModel.jpg]

== Architecture and Procedure ==
 
The architecture is shown in the figure. UpRight works as follows:
  # The client issues a request to the client library.
  # The client library sends the request to UpRight Core and waits for the reply. It returns the result to the client once it has a sufficient number (b+1) of matching replies to guarantee correctness.
  # The UpRight core agrees on the order of requests from all clients.
  # The UpRight core sends requests to server library in order.
  # The server library sends requests to the _Main_ server instance, which will execute the request and send reply back to the server library.
  # The server library sends reply to client library.
  # Periodically, the server library asks the _Main_ server instance to flush logs to disks and then the server library asks the _Backup_ server instance to load and replay the log.
  # Periodically, the server library asks the _Backup_ server instance to perform checkpoint. The checkpoint interval is much larger than the log flush interval.

= Creating an UpRight Service =
  # Server: to be incorporated into the UpRight system, the application server needs to implement two sets of interfaces: the MainAppCPInterface and BackupAppCPInterface. The first interface defines the functionality of the _Main_ server instance, including request execution, log flushing, log replay and recovery. The second interface defines the functionality of the _Backup_ server instance, including log replay, checkpoint and recovery. Notice both interfaces include functions of log replay and recovery. Actually, it is possible to use the same code for both interfaces.
  # Client: the client library provides an interface to send requests. The application client should use this interface instead of sending requests to sockets.
For details of these interfaces, see [InterfaceSpecification interface specification]. <br/>
We have provided an example of how to build an UpRight Service. It is a remote hashtable, in which clients can set or get key/value pairs on the server. The example is rather simple, but has all the features described above. [UpRightExample Go to the example].

 