#summary A simple example of how to implement the upright interfaces.

This example provides a remote hashtable, in which the client can set or get a key-value pair on the server.

=Define request and reply formats=
{{{
package Applications.hashtable;

import java.io.ByteArrayInputStream;
import java.io.ByteArrayOutputStream;
import java.io.DataInputStream;
import java.io.DataOutput;
import java.io.DataOutputStream;
import java.io.IOException;

public class HTRequest {
        enum ht_req_type {READ, WRITE};
        ht_req_type type;
        String key;
        int value;

        HTRequest(ht_req_type type, String key,int val){
                this.type = type;
                this.key = key;
                if(type == ht_req_type.WRITE){
                        value = val;
                }
        }

        private HTRequest(){

        }

        public static HTRequest getHTReqeustFromBytes(byte[] bytes){
                HTRequest ret = new HTRequest();
                ByteArrayInputStream bais = new ByteArrayInputStream(bytes);
                DataInputStream dis = new DataInputStream(bais);
                try{
                        if(dis.readBoolean()){
                                ret.type = ht_req_type.WRITE;
                                ret.key = dis.readUTF();
                                ret.value = dis.readInt();
                        } else {
                                ret.type = ht_req_type.READ;
                                ret.key = dis.readUTF();
                        }
                }catch(IOException e){
                        System.err.println(e.getLocalizedMessage());
                        System.exit(-1);
                }

                return ret;
        }

        public byte[] toBytes(){

                ByteArrayOutputStream baos = new ByteArrayOutputStream();
                DataOutput dataOutput = new DataOutputStream(baos);
                try{
                        if(type == ht_req_type.WRITE){
                                dataOutput.writeBoolean(true);
                                dataOutput.writeUTF(key);
                                dataOutput.writeInt(value);
                        }else{
                                dataOutput.writeBoolean(false);
                                dataOutput.writeUTF(key);
                        }

                }catch(IOException e){
                        System.err.println(e.getLocalizedMessage());
                        System.exit(-1);
                }

                return baos.toByteArray();
        }

}
}}}

{{{
package Applications.hashtable;

import java.io.ByteArrayInputStream;
import java.io.ByteArrayOutputStream;
import java.io.DataInputStream;
import java.io.DataOutput;
import java.io.DataOutputStream;
import java.io.IOException;

import Applications.hashtable.HTRequest.ht_req_type;

public class HTReply {

        boolean error;
        int value;

        HTReply(Boolean err, int val){
                error = err;
                value = val;
        }

        HTReply(){

        }

        public static HTReply getHTReplyFromBytes(byte[] bytes){
                HTReply ret = new HTReply();
                ByteArrayInputStream bais = new ByteArrayInputStream(bytes);
                DataInputStream dis = new DataInputStream(bais);
                try{
                        ret.error = dis.readBoolean();
                        ret.value = dis.readInt();
                }catch(IOException e){
                        System.err.println(e.getLocalizedMessage());
                        System.exit(-1);
                }

                return ret;
        }

        public byte[] toBytes(){
                ByteArrayOutputStream baos = new ByteArrayOutputStream();
                DataOutput dataOutput = new DataOutputStream(baos);
                try{
                        dataOutput.writeBoolean(error);
                        dataOutput.writeInt(value);
                }catch(IOException e){
                        System.err.println(e.getLocalizedMessage());
                        System.exit(-1);
                }

                return baos.toByteArray();
        }

}
}}}
=Application Client=
{{{
package Applications.hashtable;

import Applications.hashtable.HTRequest.ht_req_type;
import BFT.clientShim.ClientShimBaseNode;
import BFT.network.TCPNetwork;

public class HTClient{
        ClientShimBaseNode clientShim;
        public HTClient(String membership, int id){
                clientShim = new ClientShimBaseNode(membership, id);
                clientShim.setNetwork(new TCPNetwork(clientShim));
                clientShim.start();
        }

        public void write(String key, int value)
        {
                 HTRequest req = new HTRequest(ht_req_type.WRITE, key, value);
                 HTReply rep = HTReply.getHTReplyFromBytes(clientShim.execute(req.toBytes()));
                 if(rep.error){
                        throw new RuntimeException("Write failed");
                 }
        }

        public int read(String key){
                HTRequest req = new HTRequest(ht_req_type.READ, key, 0);
                HTReply rep = HTReply.getHTReplyFromBytes(clientShim.execute(req.toBytes()));
                if(rep.error){
                      throw new RuntimeException("Read failed");
                }
                return rep.value;
        }
}
}}}

=Application Server=
{{{
package Applications.hashtable;

import java.io.DataInputStream;
import java.io.DataOutputStream;
import java.io.File;
import java.io.FileInputStream;
import java.io.FileNotFoundException;
import java.io.FileOutputStream;
import java.io.IOException;
import java.io.ObjectInputStream;
import java.io.ObjectOutputStream;
import java.util.LinkedHashMap;
import java.util.LinkedList;

import Applications.hashtable.HTRequest.ht_req_type;
import BFT.generalcp.CPAppInterface;
import BFT.generalcp.MainAppCPInterface;
import BFT.generalcp.BackupAppCPInterface;
import BFT.generalcp.GeneralCP;
import BFT.generalcp.RequestInfo;
import BFT.serverShim.ShimBaseNode;
import java.io.EOFException;
import java.util.Collection;
import java.util.Iterator;

public class HTSingleApp implements MainAppCPInterface, BackupAppCPInterface{

        LinkedHashMap<String, Integer> ht;
        CPAppInterface generalCP;

        DataOutputStream log;
        String logfile;
    DataOutputStream sync;
        String syncfile;
    int syncCounter;

        private String log_prefix=null;
        private String sync_prefix=null;
        static String syncbasename="ht_sync_";

        public HTSingleApp(String log_prefix, String sync_prefix) throws IOException {
                this.log_prefix=log_prefix+File.separator;
                this.sync_prefix=sync_prefix+File.separator;
                ht = new LinkedHashMap<String, Integer>();
                File logDir = new File(this.log_prefix);
                logDir.mkdirs();
                logfile = this.log_prefix+"ht_log_0";
                log = new DataOutputStream(new FileOutputStream(logfile));
                syncCounter = 0;
                syncfile = syncbasename+syncCounter;
       }

        public void setGenCP(CPAppInterface cp) {
                generalCP = cp;
        }

        @Override
        public synchronized void execAsync(byte[] request, RequestInfo info) {

                HTRequest req = HTRequest.getHTReqeustFromBytes(request);
                HTReply rep = new HTReply();
                String key = req.key;
                if(req.type == ht_req_type.READ){

                        if(ht.containsKey(key)){
                                rep.error = false;
                                rep.value = ht.get(key);
                        }else{
                                rep.error = true;
                        }
                } else {
                        // WRITE operation
                        try {
                                // log this request
                                log.writeUTF(key);
                                log.writeInt(req.value);
                        } catch (IOException e) {
                                // TODO Auto-generated catch block
                                e.printStackTrace();
                                System.exit(-1);
                        }
                        ht.put(key, req.value);
                        rep.error = false;
                }

                generalCP.execDone(rep.toBytes(), info);

        }

        @Override
        public synchronized void flushAndStartNewLog(long seqNo) {
                DataOutputStream oldLog = log;
                //LogInfo info = new LogInfo(oldLog, logfile, seqNo);
                //logQueue.enqueue(info);
            try {
                oldLog.flush();
                oldLog.close();
                File logFile = new File(logfile);

            } catch (IOException e) {
                e.printStackTrace();
                System.exit(-1);
            }
            logfile = log_prefix+"ht_log_" + seqNo;
            try {
                    log = new DataOutputStream(new FileOutputStream(logfile));
            } catch (FileNotFoundException e) {
                    e.printStackTrace();
                    System.exit(-1);
            }
            generalCP.flushDone(seqNo, log_prefix+"log_"+seqNo);
        }

        @Override
        public void consumeLog(String fileName) {
                DataInputStream is = null;
            try {
                is = new DataInputStream(new FileInputStream(fileName));
                while (true) { // exception catches EOF
                    String key = is.readUTF();
                    int value = is.readInt();

                    ht.put(key, value);
                }
            } catch (EOFException eof) {
                System.out.println(" >> Normal program termination.");
            } catch (FileNotFoundException noFile) {
                System.err.println("File not found! " + noFile);
            } catch (IOException io) {
                System.err.println("I/O error occurred: " + io);
            } catch (Throwable anything) {
                System.err.println("Abnormal exception caught !: " + anything);
            } finally {
                if (is != null) {
                    try {
                        is.close();
                    } catch (IOException ignored) {
                    }
                }
            }

            generalCP.consumeLogDone(fileName);

        }

        @Override
        public synchronized void loadSnapshot(String fileName) {
                try {
                        ObjectInputStream ois = new ObjectInputStream(new FileInputStream(fileName));
                        ht = (LinkedHashMap<String, Integer>) ois.readObject();
                        int index=fileName.indexOf(syncbasename);
                        syncCounter=Integer.parseInt(fileName.substring(index+syncbasename.length()));
                        syncCounter++;
                        syncfile=syncbasename + syncCounter;
                        generalCP.loadSnapshotDone();
                } catch (FileNotFoundException e) {
                        e.printStackTrace();
                        System.exit(-1);
                } catch (IOException e) {
                        e.printStackTrace();
                        System.exit(-1);
                } catch (ClassNotFoundException e) {
                        e.printStackTrace();
                        System.exit(-1);
                }
                generalCP.loadSnapshotDone();

        }

        public void sync() {
            try {
                ObjectOutputStream oos = new ObjectOutputStream(new FileOutputStream(sync_prefix+syncfile));
                oos.writeObject(ht);
            } catch (FileNotFoundException e) {
                e.printStackTrace();
                System.exit(-1);
            } catch (IOException e) {
                e.printStackTrace();
                System.exit(-1);
            }
            String writtenSyncFile = syncfile;
            syncCounter++;
            syncfile = syncbasename + syncCounter;

            generalCP.syncDone(sync_prefix+writtenSyncFile);
        }

        public static void main(String args[]) throws Exception{

            if(args.length!=4){
                System.out.println("Usage: java Applications.hashtable <id> <config_file> <log_path> <snapshot_path>");
            }
            GeneralCP generalCP = new GeneralCP(Integer.parseInt(args[0]), args[1], args[2], args[3]);
            HTSingleApp main = new HTSingleApp(args[2],args[3]);
            HTSingleApp helper = new HTSingleApp(args[2], args[3]);
            main.setGenCP(generalCP);
            helper.setGenCP(generalCP);
            generalCP.setupApplication(main, helper);
        }

}


}}}